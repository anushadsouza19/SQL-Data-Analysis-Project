# SQL-Data-Analysis-Project
### a) Magnitude Analysis
#### Purpose:
 ######    - To quantify data and group results by specific dimensions.
 ######    - For understanding data distribution across categories.

#### SQL Functions Used:
 ######    - Aggregate Functions: SUM(), COUNT(), AVG()
  ######   - GROUP BY, ORDER BY

#### Question: 
Find total customers by countries
```bash
SELECT
    country,
    COUNT(customer_key) AS total_customers
FROM gold.dim_customers
GROUP BY country
ORDER BY total_customers DESC;
```
![image](https://github.com/user-attachments/assets/ee5d4dd0-5c51-42f0-a0be-48778dfd614c)

#### Question: 
Find total customers by gender
```bash
SELECT
    gender,
    COUNT(customer_key) AS total_customers
FROM gold.dim_customers
GROUP BY gender
ORDER BY total_customers DESC;
```
![image](https://github.com/user-attachments/assets/3307aef9-e0e2-4ec7-9823-3ba3cc287a9b)

#### Question: 
Find total products by category
```bash
SELECT
    category,
    COUNT(product_key) AS total_products
FROM gold.dim_products
GROUP BY category
ORDER BY total_products DESC;
```
![image](https://github.com/user-attachments/assets/2b7aad60-9c65-4a80-9f47-348a4430a0c2)

#### Question: 
What is the average costs in each category?
```bash
SELECT
    category,
    AVG(cost) AS avg_cost
FROM gold.dim_products
GROUP BY category
ORDER BY avg_cost DESC;
```
![image](https://github.com/user-attachments/assets/532485a2-bd0b-4600-8138-25a281a651a0)

#### Question: 
What is the total revenue generated for each category?
```bash
SELECT
    p.category,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.category
ORDER BY total_revenue DESC;
```
![image](https://github.com/user-attachments/assets/1610f440-0fc4-4901-949d-6a7d98577fd7)

#### Question: 
What is the total revenue generated by each customer?
```bash
SELECT
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;
```
![image](https://github.com/user-attachments/assets/6e22ff7e-2bde-4de0-a904-a311e40ef794)

#### Question: 
What is the distribution of sold items across countries?
```bash
SELECT
    c.country,
    SUM(f.quantity) AS total_sold_items
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY c.country
ORDER BY total_sold_items DESC;
```
![image](https://github.com/user-attachments/assets/eac72da7-ae1a-41dd-82f4-309f4aedb815)

### b) Date Range Exploration 
#### Purpose:
######    - To determine the temporal boundaries of key data points.
######    - To understand the range of historical data.

#### SQL Functions Used:
######    - MIN(), MAX(), DATEDIFF()

#### Question:
Determine the first and last order date and the total duration in months
```bash
SELECT 
    MIN(order_date) AS first_order_date,
    MAX(order_date) AS last_order_date,
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS order_range_months
FROM gold.fact_sales;
```
#### Question: 
Find the youngest and oldest customer based on birthdate
```bash
SELECT
    MIN(birthdate) AS oldest_birthdate,
    DATEDIFF(YEAR, MIN(birthdate), GETDATE()) AS oldest_age,
    MAX(birthdate) AS youngest_birthdate,
    DATEDIFF(YEAR, MAX(birthdate), GETDATE()) AS youngest_age
FROM gold.dim_customers;
```
![image](https://github.com/user-attachments/assets/901520ca-540f-41d8-af16-c206e31cb19c)

### c) Ranking Analysis
#### Purpose:
######    - To rank items (e.g., products, customers) based on performance or other metrics.
######    - To identify top performers or laggards.

#### SQL Functions Used:
######    - Window Ranking Functions: RANK(), DENSE_RANK(), ROW_NUMBER(), TOP
######    - Clauses: GROUP BY, ORDER BY

#### Question: 
Which 5 products Generating the Highest Revenue?
```bash
-- Simple Ranking Method
SELECT TOP 5
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue DESC;
```
![image](https://github.com/user-attachments/assets/fd3ca3a5-b74b-4d2f-a6d0-a9264babdbb3)

```bash
-- Complex but Flexibly Ranking Using Window Functions
SELECT *
FROM (
    SELECT
        p.product_name,
        SUM(f.sales_amount) AS total_revenue,
        RANK() OVER (ORDER BY SUM(f.sales_amount) DESC) AS rank_products
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.product_name
) AS ranked_products
WHERE rank_products <= 5;
```
![image](https://github.com/user-attachments/assets/66507612-e8b7-48b4-8457-9871ce9cdfd8)

#### Question: 
What are the 5 worst-performing products in terms of sales?
```bash
SELECT TOP 5
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue;
```
![image](https://github.com/user-attachments/assets/4851e203-cd39-42ab-89c8-8b9d222b145d)

#### Question: 
Find the top 10 customers who have generated the highest revenue
```bash
SELECT TOP 10
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;
```
![image](https://github.com/user-attachments/assets/92ca126c-c464-434e-a475-35cb4b0d2583)

#### Question: 
The 3 customers with the fewest orders placed
```bash
SELECT TOP 3
    c.customer_key,
    c.first_name,
    c.last_name,
    COUNT(DISTINCT order_number) AS total_orders
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_orders ;
```
![image](https://github.com/user-attachments/assets/92180c61-6927-40d4-8955-52b138dd1f00)

### d) Change Over Time Analysis
#### Purpose:
   ###### - To track trends, growth, and changes in key metrics over time.
   ###### - For time-series analysis and identifying seasonality.
   ######  - To measure growth or decline over specific periods.
#### SQL Functions Used:
   ###### - Date Functions: DATEPART(), DATETRUNC(), FORMAT()
   ###### - Aggregate Functions: SUM(), COUNT(), AVG()
#### Question: 
Analyse sales performance over time 
```bash
SELECT
    DATETRUNC(month, order_date) AS order_date,
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers,
    SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(month, order_date)
ORDER BY DATETRUNC(month, order_date);
```
![image](https://github.com/user-attachments/assets/dee3fea2-79aa-46f3-8bbf-f7955acc75f1)

### e) Cumulative Analysis
#### Purpose:
   ###### - To calculate running totals or moving averages for key metrics.
   ###### - To track performance over time cumulatively.
   ###### - Useful for growth analysis or identifying long-term trends.
#### SQL Functions Used:
   ###### -- Window Functions: SUM() OVER(), AVG() OVER()
#### Question: 
Calculate the total sales per month and the running total of sales over time 
```bash
SELECT
	order_date,
	total_sales,
	SUM(total_sales) OVER (ORDER BY order_date) AS running_total_sales,
	AVG(avg_price) OVER (ORDER BY order_date) AS moving_average_price
FROM
(
    SELECT 
        DATETRUNC(month, order_date) AS order_date,
        SUM(sales_amount) AS total_sales,
        AVG(price) AS avg_price
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATETRUNC(month, order_date)
) t
```
![image](https://github.com/user-attachments/assets/b3cba570-5180-4b8a-806c-fc398fd23c1a)

### f) Part-to-Whole Analysis
#### Purpose:
 ######    - To compare performance or metrics across dimensions or time periods.
  ######   - To evaluate differences between categories.
  ######   - Useful for A/B testing or regional comparisons.

#### SQL Functions Used:
 ######    - SUM(), AVG(): Aggregates values for comparison.
 ######    - Window Functions: SUM() OVER() for total calculations.

#### Question: 
Which categories contribute the most to overall sales?
```bash
WITH category_sales AS (
    SELECT
        p.category,
        SUM(f.sales_amount) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.category
)
SELECT
    category,
    total_sales,
    SUM(total_sales) OVER () AS overall_sales,
    ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER ()) * 100, 2) AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;
```
![image](https://github.com/user-attachments/assets/ee0725e7-5e1f-41aa-ba2d-cca53c1453f8)

### g) Part-to-Whole Analysis
#### Purpose:
######    - To compare performance or metrics across dimensions or time periods.
######   - To evaluate differences between categories.
 ######    - Useful for A/B testing or regional comparisons.

#### SQL Functions Used:
 ######    - SUM(), AVG(): Aggregates values for comparison.
  ######   - Window Functions: SUM() OVER() for total calculations.

#### Question:
Which categories contribute the most to overall sales?
```bash
WITH category_sales AS (
    SELECT
        p.category,
        SUM(f.sales_amount) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.category
)
SELECT
    category,
    total_sales,
    SUM(total_sales) OVER () AS overall_sales,
    ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER ()) * 100, 2) AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;
```
![image](https://github.com/user-attachments/assets/4e2a390c-da2e-40c3-a284-a296ae7a89d0)

### h) Data Segmentation Analysis
#### Purpose:
 ######   - To group data into meaningful categories for targeted insights.
 ######   - For customer segmentation, product categorization, or regional analysis.

#### SQL Functions Used:
 ######   - CASE: Defines custom segmentation logic.
 ######   - GROUP BY: Groups data into segments.

#### Question: 
Segment products into cost ranges and 
count how many products fall into each segment
```bash
WITH product_segments AS (
    SELECT
        product_key,
        product_name,
        cost,
        CASE 
            WHEN cost < 100 THEN 'Below 100'
            WHEN cost BETWEEN 100 AND 500 THEN '100-500'
            WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
            ELSE 'Above 1000'
        END AS cost_range
    FROM gold.dim_products
)
SELECT 
    cost_range,
    COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC;
```
![image](https://github.com/user-attachments/assets/54c0ce3c-c54f-470b-8c9f-80ed943e03a3)

 ###### Group customers into three segments based on their spending behavior:
 ######	- VIP: Customers with at least 12 months of history and spending more than €5,000.
 ######	- Regular: Customers with at least 12 months of history but spending €5,000 or less.
 ######	- New: Customers with a lifespan less than 12 months.
#### Question:
And find the total number of customers by each group
```bash
WITH customer_spending AS (
    SELECT
        c.customer_key,
        SUM(f.sales_amount) AS total_spending,
        MIN(order_date) AS first_order,
        MAX(order_date) AS last_order,
        DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    GROUP BY c.customer_key
)
SELECT 
    customer_segment,
    COUNT(customer_key) AS total_customers
FROM (
    SELECT 
        customer_key,
        CASE 
            WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
            WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
            ELSE 'New'
        END AS customer_segment
    FROM customer_spending
```
![image](https://github.com/user-attachments/assets/de42bf2b-a384-4b93-926a-affd82040ca1)


### i) Performance Analysis (Year-over-Year, Month-over-Month)
#### Purpose:
  ###### - To measure the performance of products, customers, or regions over time.
  ###### - For benchmarking and identifying high-performing entities.
  ###### - To track yearly trends and growth.

#### SQL Functions Used:
  ###### - LAG(): Accesses data from previous rows.
  ###### - AVG() OVER(): Computes average values within partitions.
  ###### - CASE: Defines conditional logic for trend analysis.

#### Question:
Analyze the yearly performance of products by comparing their sales to both the average sales performance of the product and the previous year's sales 
```bash 
WITH yearly_product_sales AS (
    SELECT
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
    GROUP BY 
        YEAR(f.order_date),
        p.product_name
)
SELECT
    order_year,
    product_name,
    current_sales,
    AVG(current_sales) OVER (PARTITION BY product_name) AS avg_sales,
    current_sales - AVG(current_sales) OVER (PARTITION BY product_name) AS diff_avg,
    CASE 
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) > 0 THEN 'Above Avg'
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) < 0 THEN 'Below Avg'
        ELSE 'Avg'
    END AS avg_change,
    -- Year-over-Year Analysis
    LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS py_sales,
    current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS diff_py,
    CASE 
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increase'
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Decrease'
        ELSE 'No Change'
    END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;
```
![image](https://github.com/user-attachments/assets/b84ab631-7b09-4f69-9401-b3b29444ba79)







